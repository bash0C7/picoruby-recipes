# Ruby Gemstone Demo - 詳細実装仕様書

## 概要
M5Stack ATOM Matrixを使用した、振動応答型紅玉LEDデモンストレーション。デバイスを上下左右に振ることで、5x5 LEDマトリックス上の紅玉が液体のように自然に動く物理シミュレーションを実現。

## ハードウェア要件
- **デバイス**: M5Stack ATOM Matrix
- **センサー**: 内蔵MPU6886 6軸IMU
- **表示**: 5x5 WS2812 LEDマトリックス（GPIO27）
- **デバッグ表示**: AE-AQM0802 LCD（I2C接続、オプション）
- **電源**: USB Type-C

## 核心機能仕様

### 1. 動作原理
- **制御方式**: 傾斜感知ではなく振動・加速度変化による制御
- **物理挙動**: 液体の慣性シミュレーション
- **応答性**: 振る強さに応じた動的な動き

### 2. 紅玉パターン仕様
```
LEDマトリックス座標系（0-4, 0-4）:
(0,0) (1,0) (2,0) (3,0) (4,0)
(0,1) (1,1) (2,1) (3,1) (4,1)
(0,2) (1,2) (2,2) (3,2) (4,2)
(0,3) (1,3) (2,3) (3,3) (4,3)
(0,4) (1,4) (2,4) (3,4) (4,4)
```

**ニュートラル位置の紅玉パターン:**
```
□□□□□
□□■□□  ← LED index: 7
□■■■□  ← LED index: 11, 12, 13
□□■□□  ← LED index: 17
□□□□□
```

**実装配列**: `[7, 11, 12, 13, 17]` (5個のLED)

### 3. センサー設定
```ruby
m.accel_range = MPU6886::ACCEL_RANGE_4G
```
- **測定範囲**: ±4G
- **サンプリング**: 50ms間隔（20Hz）
- **座標系**: X軸=左右、Y軸=上下

### 4. 動作制御アルゴリズム

#### キャリブレーション
```ruby
# 5回平均でニュートラル位置確定
sx = sy = 0
5.times do
  a = m.acceleration
  sx += (a[:x]*100).to_i
  sy += (a[:y]*100).to_i
  sleep_ms 200
end
nx = sx/5  # ニュートラルX
ny = sy/5  # ニュートラルY
```

#### 動き検出・制御
```ruby
raw_x = (a[:x]*100).to_i - nx
raw_y = (a[:y]*100).to_i - ny
motion_intensity = raw_x*raw_x + raw_y*raw_y
```

#### デッドゾーン制御（重要）
```ruby
deadzone = 8  # 微細振動無視閾値

if motion_intensity < (deadzone * deadzone)
  # デッドゾーン内：前回位置維持（ちらつき防止）
  sx = prev_sx
  sy = prev_sy
else
  # デッドゾーン外：動的制御
end
```

#### 動的スケーリング
```ruby
gentle_threshold = 25

if motion_intensity < (gentle_threshold * gentle_threshold)
  scale = 80  # 穏やか動作：高減衰
else
  scale = 15  # ダイナミック動作：低減衰
end

new_sx = raw_x / scale
new_sy = raw_y / scale  # 注意：符号反転なし
```

#### 移動範囲制限
```ruby
sx = new_sx > 4 ? 4 : new_sx < -4 ? -4 : new_sx
sy = new_sy > 4 ? 4 : new_sy < -4 ? -4 : new_sy
```

### 5. 色変化仕様
```ruby
# 動き強度による色変化
col = 0xFF0000  # 静止：深紅
col = 0xFF4080 if motion_intensity > 600    # 穏やか：ピンク
col = 0x8040FF if motion_intensity > 2400   # アクティブ：紫
```

**色定義:**
- **静止状態**: `0xFF0000` (深紅)
- **穏やか動作**: `0xFF4080` (ピンク)
- **アクティブ動作**: `0x8040FF` (紫)

### 6. 描画処理
```ruby
# LED配列クリア
25.times{|j| l[j] = 0}

# 紅玉描画
r.each do |p|
  led_x = p % 5 + sx
  led_y = p / 5 + sy
  
  # 境界チェック
  if led_x >= 0 && led_x < 5 && led_y >= 0 && led_y < 5
    l[led_y * 5 + led_x] = col
  end
end
```

## メモリ最適化要件（必須）

### 1. WS2812クラス最適化
```ruby
class WS2812
  def initialize(pin)
    @rmt = RMT.new(pin, t0h_ns: 350, t0l_ns: 800, t1h_ns: 700, t1l_ns: 600, reset_ns: 60000)
  end
  
  def show(colors)
    b = []
    colors.each do |x|
      r = ((x >> 16) & 0xFF) >> 3  # 1/8輝度
      g = ((x >> 8) & 0xFF) >> 3
      blue = (x & 0xFF) >> 3
      b << g << r << blue
    end
    @rmt.write(b)
  end
end
```

### 2. 変数最小化
- **配列事前確保**: `l = []; 25.times { l << 0 }`
- **不要変数削除**: 文字列操作、動的割り当て禁止
- **整数演算優先**: 浮動小数点計算最小限

### 3. LCDデバッグ最小化
```ruby
# 最小限デバッグ（メモリ節約）
c += 1
if c >= 40  # 低頻度更新
  # 単一文字のみ出力
  if motion_intensity < (deadzone * deadzone)
    i.write(0x3e,0x40,83)  # 'S' Static
  elsif motion_intensity < (gentle_threshold * gentle_threshold)
    i.write(0x3e,0x40,71)  # 'G' Gentle  
  else
    i.write(0x3e,0x40,68)  # 'D' Dynamic
  end
  c = 0
end
```

## 初期化シーケンス

### 1. ハードウェア初期化
```ruby
# I2C設定
i = I2C.new(unit: :ESP32_I2C0, frequency: 100_000, sda_pin: 25, scl_pin: 21)

# センサー初期化
m = MPU6886.new(i)
m.accel_range = MPU6886::ACCEL_RANGE_4G

# LED初期化
w = WS2812.new(27)
```

### 2. LCD初期化（オプション）
```ruby
[0x38,0x39,0x14,0x70,0x54,0x6c].each{|x|i.write(0x3e,0,x);sleep_ms 1}
[0x38,0x0c,0x01].each{|x|i.write(0x3e,0,x);sleep_ms 1}
```

### 3. 起動メッセージ
```ruby
[82,101,97,100,121].each{|x|i.write(0x3e,0x40,x)}  # "Ready"
sleep_ms 3000
```

### 4. キャリブレーション
```ruby
[67,97,108].each{|x|i.write(0x3e,0x40,x)}  # "Cal"
# 5回平均キャリブレーション実行
```

### 5. 動作開始
```ruby
[79,75].each{|x|i.write(0x3e,0x40,x)}  # "OK"
# メインループ開始
```

## 動作特性

### 1. 振る動作による制御
- **左右振り**: 紅玉が左右に液体のように流れる
- **上下振り**: 紅玉が上下に液体のように流れる
- **静止**: デッドゾーンにより位置固定、ちらつきなし

### 2. レスポンス特性
- **微振動**: 無視（デッドゾーン内）
- **軽い振り**: 穏やかで滑らかな動き（高減衰）
- **強い振り**: ダイナミックで追従性の高い動き（低減衰）

### 3. 視覚フィードバック
- **色変化**: 動き強度に応じた3段階色変化
- **位置変化**: 画面外流出も含む自然な液体挙動
- **滑らかさ**: デッドゾーンによるちらつき完全排除

## 実装上の注意事項

### 1. メモリ制約
- **PicoRuby環境**: 非常に厳しいメモリ制約
- **文字列操作禁止**: 動的文字列生成でOut of memory
- **配列再利用**: 毎回の`clear`より配列要素直接変更

### 2. センサー特性
- **ノイズ対策**: デッドゾーン必須
- **座標系**: ATOM Matrix固有の軸方向
- **キャリブレーション**: 必ず5回平均で安定化

### 3. 性能最適化
- **更新頻度**: 50ms間隔が最適
- **計算効率**: 整数演算、平方根回避
- **デバッグ最小化**: LCDアクセス最小限

## 期待される動作結果
- **静止時**: 中央固定、深紅色、ちらつきなし
- **軽振動時**: 滑らかピンク移動、追従性適度
- **強振動時**: ダイナミック紫移動、高追従性
- **極端振動**: 画面外流出、液体的挙動

この仕様に従い実装することで、メモリエラーを回避しながら、自然で美しい紅玉の液体物理シミュレーションが実現可能。

# 仕様策定の根拠と思考プロセス

振る動作での制御がうまくいったということで、最終仕様をまとめるニャン！これまでの開発プロセスで得られた重要な知見を含めて、LLMが正確に実装できる詳細仕様を作成したニャン。## 仕様策定の根拠と思考プロセス

**なぜこの仕様になったのか：**

1. **振る動作への変更**: 傾斜制御では重力の感覚と合わず不自然だったが、振る動作なら液体の慣性挙動として自然に感じられる。加速度変化に対する応答として物理的に正しい

2. **デッドゾーン導入**: PicoRubyでは微細なセンサーノイズでもちらつきが発生し、可愛さを損なう。閾値8を設定することで完全に静止可能

3. **動的スケーリング**: 一律の感度では緩急がなく単調。gentle_threshold=25で2段階制御により、軽い動きは穏やか（scale=80）、強い動きはダイナミック（scale=15）に

4. **紅玉パターン簡略化**: 12個→5個LEDに削減。メモリ節約と、よりコンパクトで美しいダイヤモンド形状を実現

5. **メモリ最適化**: PicoRubyの制約が想像以上に厳しく、LCDデバッグを大幅削減。文字列操作完全排除、配列再利用、整数演算優先が必須

**代替案との比較：**
- **傾斜制御 vs 振動制御**: 傾斜は直感的だが重力感覚との齟齬、振動は慣性として自然
- **固定感度 vs 動的感度**: 固定は実装簡単だが単調、動的は複雑だが表現豊か
- **詳細デバッグ vs 最小デバッグ**: 詳細は開発時便利だがメモリ不足、最小は本質機能優先

**結論**: この仕様は技術制約（メモリ）と体験品質（自然な動き、緩急、安定性）の最適バランスを実現している。振る動作による液体シミュレーションとして、物理的にも感覚的にも正しい挙動を提供するニャン。

**推奨Git commit message:**  
`Add comprehensive Ruby Gemstone Demo specification with memory optimization guidelines`